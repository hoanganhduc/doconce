

%% This file was auto-generated by IPython.
%% Conversion from the original notebook file:
%%
\documentclass[11pt,english]{article}

%% This is the automatic preamble used by IPython.  Note that it does *not*
%% include a documentclass declaration, that is added at runtime to the overall
%% document.

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}

% Scale down larger images
\usepackage[export]{adjustbox}

%fancy verbatim
\usepackage{fancyvrb}
% needed for markdown enumerations to work
\usepackage{enumerate}

% Slightly bigger margins than the latex defaults
\usepackage{geometry}
\geometry{verbose,tmargin=3cm,bmargin=3cm,lmargin=2.5cm,rmargin=2.5cm}

% Define a few colors for use in code, links and cell shading
\usepackage{color}
\definecolor{orange}{cmyk}{0,0.4,0.8,0.2}
\definecolor{darkorange}{rgb}{.71,0.21,0.01}
\definecolor{darkgreen}{rgb}{.12,.54,.11}
\definecolor{myteal}{rgb}{.26, .44, .56}
\definecolor{gray}{gray}{0.45}
\definecolor{lightgray}{gray}{.95}
\definecolor{mediumgray}{gray}{.8}
\definecolor{inputbackground}{rgb}{.95, .95, .85}
\definecolor{outputbackground}{rgb}{.95, .95, .95}
\definecolor{traceback}{rgb}{1, .95, .95}

% new ansi colors
\definecolor{brown}{rgb}{0.54,0.27,0.07}
\definecolor{purple}{rgb}{0.5,0.0,0.5}
\definecolor{darkgray}{gray}{0.25}
\definecolor{lightred}{rgb}{1.0,0.39,0.28}
\definecolor{lightgreen}{rgb}{0.48,0.99,0.0}
\definecolor{lightblue}{rgb}{0.53,0.81,0.92}
\definecolor{lightpurple}{rgb}{0.87,0.63,0.87}
\definecolor{lightcyan}{rgb}{0.5,1.0,0.83}

% Framed environments for code cells (inputs, outputs, errors, ...).  The
% various uses of \unskip (or not) at the end were fine-tuned by hand, so don't
% randomly change them unless you're sure of the effect it will have.
\usepackage{framed}

% remove extraneous vertical space in boxes
\setlength\fboxsep{0pt}

% codecell is the whole input+output set of blocks that a Code cell can
% generate.

% TODO: unfortunately, it seems that using a framed codecell environment breaks
% the ability of the frames inside of it to be broken across pages.  This
% causes at least the problem of having lots of empty space at the bottom of
% pages as new frames are moved to the next page, and if a single frame is too
% long to fit on a page, will completely stop latex from compiling the
% document.  So unless we figure out a solution to this, we'll have to instead
% leave the codecell env. as empty.  I'm keeping the original codecell
% definition here (a thin vertical bar) for reference, in case we find a
% solution to the page break issue.

%% \newenvironment{codecell}{%
%%     \def\FrameCommand{\color{mediumgray} \vrule width 1pt \hspace{5pt}}%
%%    \MakeFramed{\vspace{-0.5em}}}
%%  {\unskip\endMakeFramed}

% For now, make this a no-op...
\newenvironment{codecell}{}

 \newenvironment{codeinput}{%
   \def\FrameCommand{\colorbox{inputbackground}}%
   \MakeFramed{\advance\hsize-\width \FrameRestore}}
 {\unskip\endMakeFramed}

\newenvironment{codeoutput}{%
   \def\FrameCommand{\colorbox{outputbackground}}%
   \vspace{-1.4em}
   \MakeFramed{\advance\hsize-\width \FrameRestore}}
 {\unskip\medskip\endMakeFramed}

\newenvironment{traceback}{%
   \def\FrameCommand{\colorbox{traceback}}%
   \MakeFramed{\advance\hsize-\width \FrameRestore}}
 {\endMakeFramed}

% New code to replace ptex2tex:
% Keep old doconce code that creates ptex2tex output
% Add new features to add envirs (like the admon envirs) ++ for
% new code with lstlistings, minted, Verbatim
% the \bpy etc envirs in latex.py, for ptex2tex, are not issued
% if any of the new cml options are used.
% Move code from doconce ptex2tex to various functions for use
% directly by latex.py?
% Make the BlueBar and Blue envirs first, then support minted
% and Verbatim, try to see how these three can have common code.
% Recall: the ptex2tex output for code is very small,
% it's all the preprocess directives that fills up code.
% Maybe all such code could be refactored in lists++ and spit out
% in either plain format or ptex2tex (the admon codes are not easy
% to spot in python, ptex2tex is easier, one sees the alternatives...)
%
%Plan: 1) make Blue and BlueBar, see if it works, then continue as above.

% Use and configure listings package for nicely formatted code
% Good: http://en.wikibooks.org/wiki/LaTeX/Source_Code_Listings (read first)
% http://tex.stackexchange.com/questions/8230/what-configuration-do-you-propose-for-listings-sty-to-make-the-output-look-comfo
%  \begin{lstlisting}[style=python]  % [style=fortran]
%
% Challenge: combining the shadowblueboxes of BlueBar with lstlistings
% a la ipynb, should be straightforward
% listings also has frames and backgrounds
%
% get rid of ptex2tex by having some listing/framed options to play
% around with + minted + plain Verbatim, all of them can be inside
% a colored frame (one should use the stable framed package, not
% mdframed if mdframed features are not required, see
% http://tex.stackexchange.com/questions/71554/framed-or-mdframed-pros-cons
% as of Se, 2012, but it seems that mdframed is what doconce uses and the future

% use escapeinside= to allow for latex commands in the code,
% has to be removed in non-latex envirs
%
% define custom styles with different colors etc for listings
% (mimic ipynb, anslistings), define a set of colors too so
% that just a few parameters govern the choice of style
%
% find a way to handle settings of parameters: \lstset in
% listings vs all the [...] args in minted and Verbatim,
% maybe minted and verbatim have some set-like command too :-)
% parameters are set by command-line args
%
% ALL THIS WILL BE MUCH EASIER TO USE THAN ptex2tex envirs,
% we can just have some preferred combinations of parameters
% (maybe as latex_code_style=name)

\usepackage{listingsutf8}
\lstset{
  language=python,
  inputencoding=utf8x,
  extendedchars=\true,
  aboveskip=\smallskipamount,
  belowskip=\smallskipamount,
  xleftmargin=2mm,
  breaklines=true,
  basicstyle=\small \ttfamily,
  showstringspaces=false,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{myteal},
  stringstyle=\color{darkgreen},
  identifierstyle=\color{darkorange},
  columns=fullflexible,  % tighter character kerning, like verb
}

% The hyperref package gives us a pdf with properly built
% internal navigation ('pdf bookmarks' for the table of contents,
% internal cross-reference links, web links for URLs, etc.)
\usepackage{hyperref}
\hypersetup{
  breaklinks=true,  % so long urls are correctly broken across lines
  colorlinks=true,
  urlcolor=blue,
  linkcolor=darkorange,
  citecolor=darkgreen,
  }

% hardcode size of all verbatim environments to be a bit smaller
\makeatletter
\g@addto@macro\@verbatim\small\topsep=0.5em\partopsep=0pt
\makeatother

% Prevent overflowing lines due to urls and other hard-to-break entities.
\sloppy




\begin{document}



\[\renewcommand{\vec}{\mathbf}\]
\section{INF5620 Project 4}

By Svenn-Arne Dragly

We are working with the nonlinear diffusion equation,

\[\rho u_t = \nabla \cdot (\alpha(u) \nabla u) + f(\vec x, t)\]

with initial condition

\[u(\vec x,0) = I(\vec x)\]

and boundary condition

\[\frac{\partial u}{\partial n} = 0\]

$\rho$ is a constant and $\alpha(u)$ is known.
\subsection{a) Finite difference approximation in time}

We introduce a finite difference approximation in time using Backward
Euler and Crank-Nicolson.

\subsubsection{Backward Euler}

For Backward Euler we rewrite our original equation as

\begin{align}
\left [\rho D_t^{-} u \right . & = \left . \nabla \cdot (\alpha(u) \nabla u) + f(\vec x, t) \right ]^n \\
\rho \left ( \frac{u^{n} - u^{n-1}}{\Delta t} \right) & = \nabla \cdot (\alpha(u^n) \nabla u^n) + f(\vec x, t_n)  \\
\rho u^{n} - \rho u^{n-1} & = \Delta t \left ( \nabla \cdot (\alpha(u^n) \nabla u^n) \right) + \Delta t f(\vec x, t_n)   \\
\rho u^{n} - \Delta t \left ( \nabla \cdot (\alpha(u^n) \nabla u^n) \right) & = \Delta t f(\vec x, t_n) + \rho u^{n-1}
\end{align}

Multiplying by $\psi_i$ and integrating yields

\begin{align}
\int_{\Omega} \left( \rho u^{n} \psi_i - \Delta t \left ( \nabla \cdot (\alpha(u^n) \nabla u^n) \right) \psi_i \right) ~ dx & = \int_\Omega \Delta t f(\vec x, t_n) \psi_i + \rho u^{n-1} \psi_i ~ dx
\end{align}

We need to linearize the second term, which is done by integration by
parts

\begin{align}
\int_{\Omega} \left( \rho u^{n} \psi_i + \Delta t \alpha(u^n) \nabla u^n \cdot \nabla \psi_i \right) ~ dx + \int_{\partial \Omega} \Delta t \alpha(u^n) \frac{\partial u^n}{\partial n} \psi_i ~ dx  & = \int_\Omega \Delta t f(\vec x, t_n) \psi_i + \rho u^{n-1} \psi_i ~ dx
\end{align}

Inserting for the boundary condition $\partial u / \partial n = 0$, we
get

\begin{align}
\int_{\Omega} \left( \rho u^{n} \psi_i + \Delta t \alpha(u^n) \nabla u^n \cdot \nabla \psi_i \right) ~ dx  & = \int_\Omega \Delta t f(\vec x, t_n) \psi_i + \rho u^{n-1} \psi_i ~ dx
\end{align}

\subsubsection{Crank-Nicolson}
\subsection{b) Picard iteration method at PDE level}

\subsubsection{Starting from the Backward Euler formulation}

We start with

\begin{align}
\rho u^{n} - \Delta t \left ( \nabla \cdot (\alpha(u^n) \nabla u^n) \right) & = \Delta t f(\vec x, t_n) + \rho u^{n-1}
\end{align}

and change the notation to use $u = u^n$ and $u_{1} = u^{n-1}$. We also
introduce $u_{\_}$ as an approximation to $u^{n-1}$, which will first be
set to the previous value, i.e. $u_{\_} = u^{n-1}$ in the first
iteration. This results in

\begin{align}
\rho u - \Delta t \left ( \nabla \cdot (\alpha(u) \nabla u) \right) & = \Delta t f(\vec x, t_n) + \rho u_{1}
\end{align}

Because this is a nonlinear equation, we rewrite it to use picard
iteration by replacing $u$ with $u_{\_}$ in $\alpha(u)$:

\begin{align}
\rho u - \Delta t \left ( \nabla \cdot (\alpha(u_{\_}) \nabla u) \right) & = \Delta t f(\vec x, t_n) + \rho u_{1}
\end{align}

This leads to the variational form

\begin{align}
\int_{\Omega} \Delta t \alpha(u_{\_}) \nabla u \cdot \nabla \psi_i ~ dx
+ \int_{\Omega}  \rho u \psi_i ~ dx  - \int_\Omega \Delta t f(\vec x, t_n) \psi_i - \rho u_1 \psi_i ~ dx &= 0
\end{align}

or in more compact notation:

\[\Delta t (\alpha(u_{\_}) \nabla u, \nabla \psi_i) + \rho(u, \psi_i) - \Delta t (f(\vec x, t_n), \psi_i) - \rho (u_1 ,\psi_i) = 0\]
\subsection{c) Singe Picard iteration implementation in FEniCS}

This is implemented in all the following exercises.
\subsection{d) Convergence test}

We now have to rewrite our problem into something that is solveable by
FEniCS:
\[\Delta t (\alpha(u_{\_}) \nabla u, \nabla \psi_i) + \rho(u, \psi_i) = \Delta t (f(\vec x, t_n), \psi_i) + \rho (u_1 ,\psi_i)\]
which may be written in terms of $a$ and $L$:
\[a(u,\psi_i) = \Delta t (\alpha(u_{\_}) \nabla u, \nabla \psi_i) + \rho(u, \psi_i)\]

\[L(\psi_i) = \Delta t (f(\vec x, t_n), \psi_i) + \rho (u_1 ,\psi_i)\]

In the code, we will write $v = \psi_i$.

To perform a convergence test, we perform several experiments with
different values of $h$ and calculate the error in each experiment. We
then compare the error of two and two consecutive experiments,
$E_i = Ch_i^r$ and $E_{i-1} Ch_{i-1}^r$, and find $r$:

\[r = \frac{\ln(E_i / E_{i-1})}{\ln(h_i / h_{i-1})}\]

This has been implemented in convergence.py and results in the following
output:

\begin{verbatim}
h=  5.00e-02 E=  2.85e-04 r=1.28283
h=  2.50e-02 E=  8.32e-05 r=1.77900
h=  1.25e-02 E=  2.76e-05 r=1.59004
h=  6.25e-03 E=  1.24e-05 r=1.15326
h=  3.13e-03 E=  6.05e-06 r=1.03878
h=  1.56e-03 E=  2.90e-06 r=1.05933
h=  7.81e-04 E=  1.41e-06 r=1.03981
h=  3.91e-04 E=  7.01e-07 r=1.00998
h=  1.95e-04 E=  3.50e-07 r=1.00250
\end{verbatim}

As we approach finer meshes, we get that $r$ goes towards a constant
$r = 1.0$, as expected.
\subsection{e) Manufactured solution test}

We use the method of manufactured solutions to get an indication of
whether we have implemented the PDE correctly or not.

\begin{codecell}


\begin{codeinput}
\begin{lstlisting}
from sympy import *
x, t, rho, dt = symbols('x[0] t rho dt')

def a(u):
    return 1 + u**2

def u_simple(x, t):
    return x**2*(Rational(1,2) - x/3)*t

# MMS: full nonlinear problem
u = u_simple(x, t)
f = rho*diff(u, t) - diff(a(u)*diff(u, x), x)
print ccode(f.simplify())
\end{lstlisting}
\end{codeinput}
\begin{codeoutput}


\begin{Verbatim}[commandchars=\\\{\}]
-rho*pow(x[0], 3)/3 + rho*pow(x[0], 2)/2 + 8*pow(t, 3)*pow(x[0], 7)/9 - 28*pow(t, 3)*pow(x[0], 6)/9 + 7*pow(t, 3)*pow(x[0], 5)/2 - 5*pow(t, 3)*pow(x[0], 4)/4 + 2*t*x[0] - t
\end{Verbatim}

\end{codeoutput}

\end{codecell}

This has been implemented in the file manufactured.py, which results in
the following output:

\begin{verbatim}
T=0.10 E=  6.68e-08
T=1.00 E=  2.12e-05
T=2.00 E=  2.04e-04
T=5.00 E=  7.45e-03
T=10.00 E=  1.28e-01
\end{verbatim}

We see that the error is quite big, even though we would might have
expected a much smaller error for a manufactured solution test?
\subsection{f) More precise manufactured solution}

We may go further, and introduce a manufactured solution based on the
Picard iteration $\alpha(u_1)$ in $f$:

\begin{codecell}


\begin{codeinput}
\begin{lstlisting}
u_1 = u_simple(x, t-dt)
f = rho*diff(u, t) - diff(a(u_1)*diff(u, x), x)
print ccode(f.simplify())
\end{lstlisting}
\end{codeinput}
\begin{codeoutput}


\begin{Verbatim}[commandchars=\\\{\}]
-rho*pow(x[0], 2)*(2*x[0] - 3)/6 + t*pow(x[0], 4)*pow(dt - t, 2)*pow(x[0] - 1, 2)*(2*x[0] - 3)/3 + t*(2*x[0] - 1)*(pow(x[0], 4)*pow(dt - t, 2)*pow(2*x[0] - 3, 2) + 36)/36
\end{Verbatim}

\end{codeoutput}

\end{codecell}

This results in the following output:

\begin{verbatim}
T=0.10 E=  3.05e-08
T=1.00 E=  1.49e-05
T=2.00 E=  1.92e-04
T=5.00 E=  7.43e-03
T=10.00 E=  1.28e-01
\end{verbatim}

These results are in fact worse than without our improvement. Perhaps
something else is wrong?
\subsection{g) Errors in FEniCS}

Some of the numerical errors in the above programs have the following
sources:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Time step from the backward Euler scheme.
\item
  Using only one Picard iteration.
\item
  Degree of our basis functions.
\item
  Evaluation of integrals in inner products.
\end{itemize}
\subsection{h) Nonlinear diffusion of Gaussian function}

This exercise is implemented in gaussian.py.

\begin{codecell}


\begin{codeinput}
\begin{lstlisting}

\end{lstlisting}
\end{codeinput}

\end{codecell}



\end{document}

